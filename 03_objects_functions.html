<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Objekty, proměnné a funkce</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 64px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h2 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h3 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h4 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h5 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h6 {
  padding-top: 69px;
  margin-top: -69px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Úvod do analýzy dat v R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Materiály k přednáškám
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="01_intro_R.html">Představení R</a>
    </li>
    <li>
      <a href="02_install_R.html">Instalace R, R studia a tidyverse</a>
    </li>
    <li>
      <a href="03_objects_functions.html">Objekty, proměnné a funkce</a>
    </li>
    <li>
      <a href="04_import_export.html">Import a export dat</a>
    </li>
    <li>
      <a href="05_dataframe_manipulation.html">Prohlížení a manipulce s dataframem</a>
    </li>
    <li>
      <a href="06_variables_mutate_summarise.html">Manipulace a sumarizace proměnných</a>
    </li>
    <li>
      <a href="07_factors.html">Práce s faktory</a>
    </li>
    <li>
      <a href="08_data_visualization.html">Vytváření grafů</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Domácí úkoly
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="03_objects_functions_homework.html">Objekty, proměnné a funkce</a>
    </li>
    <li>
      <a href="04_import_export_homework.html">Import a export</a>
    </li>
    <li>
      <a href="05_dataframe_manipulation_homework.html">Prohlížení data framu</a>
    </li>
    <li>
      <a href="06_variables_mutate_summarise_homework.html">Dplyr 1 - funkce mutate, summarise atd.</a>
    </li>
    <li>
      <a href="06_c_dplyr_warmup.html">Dplyr 1.5 - warm-up from class</a>
    </li>
    <li>
      <a href="06_b_variables_mutate_summarise_homework.html">Dplyr 2 - funkce mutate, summarise atd.</a>
    </li>
  </ul>
</li>
<li>
  <a href="atestation.html">Atestace</a>
</li>
<li>
  <a href="course_data.html">Data</a>
</li>
<li>
  <a href="literature.html">Literatura</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Objekty, proměnné a funkce</h1>

</div>


<p>R je v základu jazyk orientovaný na objekty (<em>object oriented language</em>). Tím je myšleno, že centrem R jsou objekty, tedy datové struktury (jednoduše, data), na rozdíl od např. funkcionálních jazyků (které chápou programování skrze optiku matematických funkcí) nebo procedurálních jazyků (které se zaměřují na sérii výpočetních kroků). Protože objekty hrají centrální úlohu při práci s R, vyplatí se znát jejich základní přehled.</p>
<div id="typy-objektů" class="section level1">
<h1>Typy objektů</h1>
<div id="atomový-vektor" class="section level2">
<h2>Atomový vektor</h2>
<p>Při práci s R se setkáme s řadou objektů. Nejzákladnějším typem objektu je takzvaný atomický vektor (<em>atomic vector</em>). Atomické vektory jsou základním stavebním kamenem R a všechny ostatní objekty, se kterými se setkáme, z nich vychází. Každý vektor má určitý počet elementů, tedy dílčích částí. Atomový vektor s jedním elementem si můžeme představit jako základní jednotku informace. Příkladem atomových vektorů s jedním elementem je:</p>
<pre class="r"><code>&quot;jablko&quot;</code></pre>
<pre><code>## [1] &quot;jablko&quot;</code></pre>
<p>Tedy jedna hodnota. Několik různých atomových vektorů lze sloučit dohromady pomocí funkce <code>c()</code> (zkratka pro <em>concatenate</em>). Například, spojením tří vektorů s jedním elementem, <code>jablko</code>, <code>pomeranč</code>, <code>hruška</code> můžeme vytvořit nový vektor s třemi elementy:</p>
<pre class="r"><code>c(&quot;jablko&quot;, &quot;pomeranč&quot;, &quot;hruška&quot;)</code></pre>
<pre><code>## [1] &quot;jablko&quot;   &quot;pomeranč&quot; &quot;hruška&quot;</code></pre>
<div id="typy-atomových-vektorů" class="section level3">
<h3>Typy atomových vektorů</h3>
<p>Ne všechny atomové vektory jsou stejné. Existuje šest typů vektorů: <code>integer</code> a <code>double</code> (dohromady spadající do kategorie <code>numeric</code>), <code>character</code>, <code>logical</code>, <code>complex</code> a <code>raw</code>. S vektory typu <code>complex</code> a <code>raw</code> se setkáme naprosto minimálně a proto se jim nebudeme více věnovat.</p>
<table>
<thead>
<tr class="header">
<th align="center">Typ vektoru</th>
<th align="center">Popis</th>
<th align="center">Příklady</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Integer</td>
<td align="center">Celé číslo</td>
<td align="center">1, 17</td>
</tr>
<tr class="even">
<td align="center">Double</td>
<td align="center">Racionální (desetinné) číslo</td>
<td align="center">2.3, 14.7</td>
</tr>
<tr class="odd">
<td align="center">Character</td>
<td align="center">Znak</td>
<td align="center">“a”, “1”, "_"</td>
</tr>
<tr class="even">
<td align="center">Logical</td>
<td align="center">Logický stav</td>
<td align="center">TRUE, FALSE, NA</td>
</tr>
</tbody>
</table>
<p>Všechny elementy atomického vektoru musí být stejného typu. Kombinace <code>c(1, 2, 3, 4, "a")</code> není platným vektorem, protože obsahuje jak čislo (konkrétně <code>integer</code>), tak znak (<code>character</code>). Pokud chceme těchto pět vektorů zkombinovat, musí být všechny ve formátu <code>character</code>, tedy <code>c("1", "2", "3", "4", "a")</code></p>
<p>Specifickou pozoronost si zaslouží <code>NA</code>, které kóduje chybějící hodnoty. R chápe <code>NA</code> jako neznámé, tedy elementy, které mohou teoreticky nabýt jakkékoliv hodnoty. To má důležité implikace pro prováděné výpočty, viz. níže. <code>NA</code> také může být součástí součástí jakkéhokoliv typu atomového vektoru, ne pouze logického (přesněji řečeno, v R existuje několik typů <code>NA</code>, ty jsou ale ve většině případů přiřazeny automaticky a není nutné je řešit).</p>
</div>
</div>
<div id="matice-matrix-a-array" class="section level2">
<h2>Matice (matrix) a Array</h2>
<p>Zatímco atomové vektory jsou jednodimenzionální, přidáním druhé dimenze vytvoříme matici (<em>matrix</em>):</p>
<pre class="r"><code>matrix(1:6, nrow = 2, ncol = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p>Jedná se o klasické matice, jak je známe z matematiky a dá se s nimi proto pracovat stejným způsobem. Rozšířením o třetí a další dimenze získáme <em>array</em>.</p>
<pre class="r"><code>array(1:12, c(2, 3, 2))</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    7    9   11
## [2,]    8   10   12</code></pre>
</div>
<div id="tabulka" class="section level2">
<h2>Tabulka</h2>
<p>Tabulka je speciální případ matice/array, která obsahuje názvy jednotlivých sloupců a řádků. Jedná se zpravidla o frekvenční a kontingenční tabulky</p>
<pre class="r"><code>table(c(&quot;jablko&quot;, &quot;jablko&quot;, &quot;jablko&quot;, &quot;pomeranč&quot;, &quot;pomeranč&quot;))</code></pre>
<pre><code>## 
##   jablko pomeranč 
##        3        2</code></pre>
</div>
<div id="faktor" class="section level2">
<h2>Faktor</h2>
<p>Faktory představují speciální typ objektu, sloužící k uchovávání kategoriálních dat. Jedná se o <code>integer</code> vektor, kde je každé číselné hodnotě přiřazen slovní název (zvaný <code>level</code>).</p>
<pre class="r"><code>factor(x = c(&quot;Souhlasím&quot;, &quot;Nesouhlasím&quot;, &quot;Nesouhlasím&quot;,&quot;Nevím&quot;, &quot;Neutrální&quot;), levels = c(&quot;Souhlasím&quot;, &quot;Neutrální&quot;, &quot;Nesouhlasím&quot;))</code></pre>
<pre><code>## [1] Souhlasím   Nesouhlasím Nesouhlasím &lt;NA&gt;        Neutrální  
## Levels: Souhlasím Neutrální Nesouhlasím</code></pre>
<p>Faktory mohou nabývat pouze předem definovaných hodnot. Všimněme si, že předposlední hodnota v příkladu výše je <code>&lt;NA&gt;</code>. To proto, že jsme nikdy nedefinovali level <em>Nevím</em>. Tato vlastnost se hodí, pokud pracujeme s předem definovanými kategoriemi (např. škála souhlasu) a všechny ostatní hodnoty musí být nutně chybné.</p>
<p>Speciální typem faktoru je seřazaný faktor (<em>ordered factor</em>). V seřazeném faktoru mají hodnoty pevně dané pořadí a hodí se proto uchovávání ordinálních proměnných.</p>
<pre class="r"><code>ordered(x = c(&quot;Souhlasím&quot;, &quot;Nesouhlasím&quot;, &quot;Nesouhlasím&quot;,&quot;Nevím&quot;, &quot;Neutrální&quot;), levels = c(&quot;Souhlasím&quot;, &quot;Neutrální&quot;, &quot;Nesouhlasím&quot;))</code></pre>
<pre><code>## [1] Souhlasím   Nesouhlasím Nesouhlasím &lt;NA&gt;        Neutrální  
## Levels: Souhlasím &lt; Neutrální &lt; Nesouhlasím</code></pre>
<p>Všimněme si, že popisu úrovní (<code>levels</code>) se oproti neseřazenému faktoru změnil.</p>
</div>
<div id="list" class="section level2">
<h2>List</h2>
<p>List představuje složitější (již ne atomový) typ vektoru. Jednotlivé elementy listu nemusí být stejného typy a mohou to být dokonce jiné listy. To je z nich dělá efektivní způsob pro uchovávání dat.</p>
<pre class="r"><code>list(numeric = c(1,2,3,4),
     character = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),
     list2 = list(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;))</code></pre>
<pre><code>## $numeric
## [1] 1 2 3 4
## 
## $character
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
## 
## $list2
## $list2[[1]]
## [1] &quot;x&quot;
## 
## $list2[[2]]
## [1] &quot;y&quot;
## 
## $list2[[3]]
## [1] &quot;z&quot;</code></pre>
</div>
<div id="dataframe" class="section level2">
<h2>Dataframe</h2>
<p>Dataframe je speciální typ listu, složený z atomových vektorů stejné délky. Vektory v data framu mohou být různých typů a musí mít unikatní jméno. Dataframe je nejčastější způsob uchovávání dat v R a budeme s ním pracovat ve většině analýz. Dataframe je obdobou toho, co se v SPSS nazývá datovou maticí.</p>
<pre class="r"><code>data.frame(numeric = c(1,2,3,4,5),
           character = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, NA, &quot;e&quot;))</code></pre>
<pre><code>##   numeric character
## 1       1         a
## 2       2         b
## 3       3         c
## 4       4      &lt;NA&gt;
## 5       5         e</code></pre>
</div>
</div>
<div id="přiřazovaní-jmen-objektům" class="section level1">
<h1>Přiřazovaní jmen objektům</h1>
<p>Pokud chceme některý objekt využívat opakovaně, je nutné mu přiřadit jméno, aby na něj bylo možné v budoucnu odkazovat. Jména objektům můžeme přiřadit pomocí funkce <code>&lt;-</code>, případně <code>=</code> (v naprosté většině situací jsou ty dvě funkce identické). Přiřazování jmen probíhá v podobě <code>jméno &lt;- objekt</code>, případně <code>jméno = objekt</code>. Například:</p>
<pre class="r"><code>x &lt;- c(1,2,3,4,5,6)</code></pre>
<p>vytvoří atomový vektor <code>c(1,2,3,4,5,6)</code> a přiřadí mu jméno <code>x</code>. V budoucnu už nebudeme muset vytvářet objekt znovu, ale můžeme ho ho zavolat jménem:</p>
<pre class="r"><code>x</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<p>Jména objektů jsou tranzitivní, můžeme tedy jednomu objektu přiřadit dvě jména, čímž ho prakticky zduplikujeme:</p>
<pre class="r"><code>x = c(1,2,3,4,5,6)
y = x

x = y = c(1,2,3,4,5,6) #stejný výsledek jako u předchozí varianta</code></pre>
<p>Přiřazování jmen se řídí jistými omezeními. Následující slova nemůžou být jmény objektu (ani funkcí): <code>if</code>, <code>else</code>, <code>repeat</code> <code>while</code>, <code>function</code>, <code>for</code>,<code>in</code>, <code>next</code>, <code>break</code>, <code>TRUE</code>, <code>FALSE</code>, <code>NULL</code>, <code>Inf</code>, <code>NaN</code>, <code>NA</code>, <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code> a <code>…</code>. Těmto výrazům se říká rezervovaná slova a jsou využívaná pro vnitřní fungování R jako programovacího jazyka (např. <code>NA</code> je rezervováno pro vyjádření chybějící hodnoty). Jméno musí začínát buď písmenem nebo tečkou. Pokud začíná tečkou, druhý znak nesmí být číslice (např. <code>.2scale</code> není validní jméno). Jména také mohou obsahovat pouze znaky, číslice, tečky nebo podtržítka (<code>_</code>).</p>
</div>
<div id="vnořené-objekty" class="section level1">
<h1>Vnořené objekty</h1>
<p>Jak jsme již viděli, některé objekty, např. dataframe nebo list, mohou obsahovat objekty jiné. Vytvořme například dataframe <code>zeme</code>, obsahující dvě proměnné (atomové vektory), <code>evropa</code> a <code>amerika</code>:</p>
<pre class="r"><code>zeme = data.frame(evropa = c(&quot;Česko&quot;, &quot;Slovensko&quot;, &quot;Německo&quot;, &quot;Francie&quot;, &quot;Norsko&quot;),
                  amerika = c(&quot;USA&quot;, &quot;Kanada&quot;, &quot;Mexiko&quot;, &quot;Brazílie&quot;, &quot;Chile&quot;))</code></pre>
<p>Tento dataframe můžeme zavolat jeho jménem:</p>
<pre class="r"><code>zeme</code></pre>
<pre><code>##      evropa  amerika
## 1     Česko      USA
## 2 Slovensko   Kanada
## 3   Německo   Mexiko
## 4   Francie Brazílie
## 5    Norsko    Chile</code></pre>
<p>Co když ale chceme pouze určitou proměnnou? Možností je několik. První možností je zavolat proměnnou pomocí jejího jména. To lze udělat pomocí znaku dolaru, a to ve formátu <code>objekt$vnoreny objekt</code>. Pokud bychom chtěli z dataframu <code>zeme</code> pouze proměnnou <code>evropa</code>:</p>
<pre class="r"><code>zeme$evropa</code></pre>
<pre><code>## [1] &quot;Česko&quot;     &quot;Slovensko&quot; &quot;Německo&quot;   &quot;Francie&quot;   &quot;Norsko&quot;</code></pre>
<p>Druhou možností je zavolat proměnnou podle jejího pořadí v objektu. K tomu slouží hranaté závorky, ve formátu <code>objekt[cislo sloupce]</code> V našem případě můžeme zavolat první proměnnou v dataframu <code>zeme</code> pomocí:</p>
<pre class="r"><code>zeme[1]</code></pre>
<pre><code>##      evropa
## 1     Česko
## 2 Slovensko
## 3   Německo
## 4   Francie
## 5    Norsko</code></pre>
<p>Poslední možností je odkázat pomocí maticové notace na konkrétní řádek nebo sloupec. I to se provádí pomocí hranatých závorek, ale ve formátu <code>objekt[řádek, sloupce]</code>.</p>
<p>Například první řádek:</p>
<pre class="r"><code>zeme[1,]</code></pre>
<pre><code>##   evropa amerika
## 1  Česko     USA</code></pre>
<p>První sloupec:</p>
<pre class="r"><code>zeme[,1]</code></pre>
<pre><code>## [1] &quot;Česko&quot;     &quot;Slovensko&quot; &quot;Německo&quot;   &quot;Francie&quot;   &quot;Norsko&quot;</code></pre>
<p>A nakonec, první řádek prvního sloupce:</p>
<pre class="r"><code>zeme[1,1]</code></pre>
<pre><code>## [1] &quot;Česko&quot;</code></pre>
</div>
<div id="funkce" class="section level1">
<h1>Funkce</h1>
<p>Funkce je speciálním typem objektu, pomocí kterého lze manipulovat s jinými objekty. funkci poznáme zpravidla podle závorek, následujících za jméném funkce samotné (tedy <code>funkce()</code>). S některými funkcemi jsme se již setkali, např. <code>table()</code>, <code>list()</code> a <code>data.frame()</code>jsou funkce vytvářející objekty stejného jména. Dalšími funkcemi jsou například <code>sum()</code>, <code>mean()</code> a <code>var()</code>. Vytvořme si následující objekt <code>cisla</code>:</p>
<pre class="r"><code>cisla = c(17, 28, 37, 41, 56)</code></pre>
<p>Pokud bychom chtěli spočítat součet hodnot v tomto objektu, stačí jednoduše použít:</p>
<pre class="r"><code>sum(cisla)</code></pre>
<pre><code>## [1] 179</code></pre>
<p>Obdobně můžeme použít i funkce <code>mean()</code>, <code>median()</code> nebo <code>var()</code>.</p>
<div id="argumenty-funkce" class="section level2">
<h2>Argumenty funkce</h2>
<p>Do většiny funkcí lze přidávat argumenty, které upravují jejich chování. Například funkce <code>sum()</code> má x argumenty:</p>
<p><strong>…</strong> - numerický nebo logický vektor, jehož součet funkce počítá.</p>
<p><strong>na.rm</strong> - logický argument řídící, jestli mají být před výpočtem součtu odstraněny chybějící hodnoty.</p>
<p>Pro ukázku toho, jak argumenty fungují, si vytvořme nový objekt:</p>
<pre class="r"><code>cisla2 = c(17, 28, 37, 41, 56, NA)</code></pre>
<p>Objekt <code>cisla2</code> je téměř stejný jako <code>cisla</code>, ale obsahuje navíc hodnotu <code>NA</code>. Pokud bychom chtěli spočítat pro něj, narazíme na problém:</p>
<pre class="r"><code>sum(cisla2)</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Součet těchto hodnot je neznámy. Jak jsme již zmínili, R interpretuje <code>NA</code> jako existující, ale neznámé hodnotu. Jelikož je poslední poslední z čísel v objektu <code>cisla2</code> neznáme, může teoreticky nabývat jakkékoliv hodnoty. A protože poslední číslo může nabývat jakkékoliv hodnoty, i součet našich čísel může být jakkýkoliv. Součet <code>cisla2</code> je tedy technicky vzato neznámy.</p>
<p>V praxi se tomuto problému můžeme jednoduše vyhnout tím, že budeme existenci chybějících hodnot ignorovat. K tomu slouží argument <code>na.rm</code>, která najdeme u celé řady funkcí. Ve výchozím nastavení funkce <code>sum()</code> je hodna argumentu <code>na.rm</code> <code>FALSE</code>, tedy chybějící hodnoty nejsou ignorovány. Pokud chceme aby R chybějící hodnoty ignorovalo:</p>
<pre class="r"><code>sum(cisla2, na.rm = TRUE)</code></pre>
<pre><code>## [1] 179</code></pre>
<p>Čímž dostaneme stejný výsledek jako pokud by chybějící hodnota neexistovala.</p>
</div>
<div id="aplikovaní-funkcí-na-vnořené-objekty" class="section level2">
<h2>Aplikovaní funkcí na vnořené objekty</h2>
<p>Pokud je nějaký objekt součástí jiného, například proměnné součástí dataframu, můžeme na něj způsoby, které jsme si ukázaly v kapitole <strong>Vnořené objekty</strong>. Vytvořme si nový dataframe <code>vyska</code>:</p>
<pre class="r"><code>vyska = data.frame(muzi = c(172, 183, 187),
                   zeny = c(174, 167, 159))</code></pre>
<p>Pokud bychom chtěli spočítat průměr proměnné <code>muzi</code>:</p>
<pre class="r"><code>mean(vyska$muzi)</code></pre>
<pre><code>## [1] 180.6667</code></pre>
<p>Případně můžeme místo názvu odkázat na sloupec podle jeho pozice v dataframu:</p>
<pre class="r"><code>mean(vyska[,1])</code></pre>
<pre><code>## [1] 180.6667</code></pre>
<p>Stejně jako můžeme odkazovat na vnořené objekty v rámci funkcí, můžeme uložit výsledek funkce jako vnořený objekt. Pokud bychom například chtěli vytvořit v dataframu <code>vyska</code> novou proměnnou <code>rozdil</code>, které představuje rozdíl mezi hodnotami proměnných <code>muzi</code> a <code>zeny</code>:</p>
<pre class="r"><code>vyska$rozdil = vyska$muzi - vyska$zeny</code></pre>
<p>Následně můžeme na tuto novou proměnnou odkazovat, například spočítat průměrný rozdíl v páru:</p>
<pre class="r"><code>mean(vyska$rozdil)</code></pre>
<pre><code>## [1] 14</code></pre>
</div>
<div id="řetězení-funkcí" class="section level2">
<h2>Řetězení funkcí</h2>
<p>V praxi budeme potřebovat pro naše účely téměř vždy aplikovat více než jednu funkci na objekty, se kterými pracujeme. Co kdybychom chtěli nejen spočítat průměr proměnné <code>muzi</code> v dataframu <code>vyska</code>, ale výsledek zaokrouhlit na celé čislo? Možností máme několika.</p>
<p>První možností je si spočítaný průměr uložit do nového objektu a ten potom zaokrouhlit:</p>
<pre class="r"><code>prumer_muzi = mean(vyska$muzi)

round(prumer_muzi)</code></pre>
<pre><code>## [1] 181</code></pre>
<p>Tento postup je přehledný, často ale vede k vytváření velkého množství nových objektů.</p>
<p>Druhou možností je funkce nabalovat na sebe. Protože výsledkem funkce je objekt, na který lze aplikovat novou funkci, můžeme udělat následující:</p>
<pre class="r"><code>round(mean(vyska$muzi))</code></pre>
<pre><code>## [1] 181</code></pre>
<p>Tento postup se na rozdíl od předchozího obejde bez vytváření nových objektů, čtení skriptu je ovšem neintuitivní a skript se rychle stává nečitelným. Pokud funkce nabalujeme na sebe, je nutné skript číst ze středu k vnějšku. Funkce <code>mean()</code> je ve středu, takže bude aplikovaná jako první, a funkce <code>round()</code> bude aplikovaná po ní.</p>
<p>Poslední možností je využít takzvané <strong>pipes</strong> (<code>%&gt;%</code>), “fajfky” pocházející z balíčku <code>magrittr</code>, ale obsažení i v balíčku <code>dplyr</code> (který je součástí <code>tidyverse</code>). <strong>Pipe</strong> (kterou můžeme rychle napsat pomocí klávesové zkratky <strong>ctrl</strong> + <strong>shift</strong> + <strong>m</strong>) je funkce, která vezme objekt (většinou dataframe) nalevo od ní a aplikuje na něj funkci napravo. Fajfky je také možné řetězit:</p>
<pre class="r"><code>vyska$muzi %&gt;% mean() %&gt;% round()</code></pre>
<pre><code>## [1] 181</code></pre>
<p>Hlavní výhodou fajfek/ <strong>pipes</strong>/<code>%&gt;%</code> je, že jejich čtění je intuitivní. Skript se čte zleva do prava jako klasický text. V našem případě první <code>%&gt;%</code> vezme objekt <code>muzi</code> (vnořený v dataframu <code>vyska</code>) a aplikuje na něj funkci <code>mean()</code>. Druhá <code>%&gt;%</code> potom vezme výsledek funkce <code>mean()</code> a aplikuje na něj funkci <code>round()</code>.</p>
<p><strong>Pipes</strong> mají dvě hlavní nevýhody. První z nich je, že jejich použití je primárně zaměřené na dataframy. Pokud jsou aplikované na jiné typy objektů, nemusí nutně fungovat. Druhou nevýhodou je, že jsou výpočetně pomalejší než ostatní postupy. U běžných datasetů je rozdíl neznatelný, ale u velmi velkých dat (velikostně v řádu gigabytů a větší) je už zpomalení znatelné.</p>
</div>
<div id="nápověda-funkcí" class="section level2">
<h2>Nápověda funkcí</h2>
<p>V tuto chvíli jsme si už stihli ukázat řadu funkcí. Co když se ale setkáme s funkcí, kterou neznáme? Nebo známe, ale zapomněli jsme, jaké jsou její argumenty nebo jak ji aplikovat? Naštěstí pro nás, R obsahuje podrobnou nápovědu pro všechny funkce, které nabízí.</p>
<p>Nápovědu můžeme zobrazit pomocí otazníků (<code>?</code>) před jménem funkce (<code>?jméno funkce</code>). Například nápovědu pro funkci <code>sum()</code> můžeme zobrazit pomocí:</p>
<pre class="help"><code>?sum()</code></pre>
<p>Nápověda většiny funkcí má standardizovaný formát, obsahující několik oddílů. Těmito oddíly jsou:</p>
<table>
<colgroup>
<col width="14%" />
<col width="85%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Oddíl</th>
<th align="left">Popis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Description</td>
<td align="left">Základní popis toho, co funkce dělá</td>
</tr>
<tr class="even">
<td align="left">Usage</td>
<td align="left">Základní nastavení funkce, resp. jejích argumentů</td>
</tr>
<tr class="odd">
<td align="left">Argument</td>
<td align="left">Argumenty funkce a jejich popis</td>
</tr>
<tr class="even">
<td align="left">Details</td>
<td align="left">Detailní popis toho, jak funkce funguje a jak je implementována</td>
</tr>
<tr class="odd">
<td align="left">Value</td>
<td align="left">Výsledek funkce, co funkce produkuje</td>
</tr>
<tr class="even">
<td align="left">References</td>
<td align="left">Zdroje využité v Description, zvlášť u statistických funkci užitečné pro teoretický popis jejich fungování</td>
</tr>
<tr class="odd">
<td align="left">See also</td>
<td align="left">Příbuzné funkce nebo funkce, které se často používají spolu s danou funkcí</td>
</tr>
<tr class="even">
<td align="left">Examples</td>
<td align="left">Příklady aplikace funkce, jak funkci používat</td>
</tr>
</tbody>
</table>
<p>Pokud si tedy nejsme jistí, co funkce dělá, je nejlepší se podívat na <em>Description</em>, a případně <em>Details</em>. Pokud si nepamatujeme, jaké argumenty funkce má, pak samozřejmě oddíl <em>Arguments</em>. A nakonec, pokud si nejsme jistí, jak funkci použít, nejlepší je podívat se na do oddílu <em>Examples</em>.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
